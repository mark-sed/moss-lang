///
/// \file bytecode_header.hpp
/// \author Marek Sedlacek
/// \copyright Copyright 2024 Marek Sedlacek. All rights reserved.
///            See accompanied LICENSE file.
/// 
/// \brief Information about bytecode header for bytecode reader and writer
///

#ifndef _BYTECODE_HEADER_HPP_
#define _BYTECODE_HEADER_HPP_

#include "moss.hpp"
#include <cstdint>
#include <ctime>

namespace moss {

/// All bytecode header related resources
namespace bc_header {

#define BCH_ID_SIZE 4             ///< Size of id in bytes
#define BCH_CHECKSUM_SIZE 4       ///< Size of checksum in bytes
#define BCH_BC_VERSION_SIZE 4     ///< Size of bytecode version in bytes
#define BCH_MOSS_VERSION_SIZE 4   ///< Size of moss version in bytes
#define BCH_TIMESTAMP_SIZE 4      ///< Size of timestamp in bytes
#define BCH_SIZE (BCH_ID_SIZE + BCH_CHECKSUM_SIZE + BCH_BC_VERSION_SIZE + BCH_MOSS_VERSION_SIZE + BCH_TIMESTAMP_SIZE) ///< Overall header size

/// Version of bytecode generated by this version of interpreter.
/// Any changes in bytecode should reflect in incrementing this version.
constexpr std::uint32_t BYTECODE_VERSION = 1;

/// Bytecode header consists of:
/// 
/// 4B | 0xFF 0x2A 0x00 0x00
/// 4B | reserved (for checksum?)
/// 4B | major, minor, patch, 0x00
/// 4B | timestamp
/// 
#ifdef __linux__
struct __attribute__((packed)) BytecodeHeader {
#else
// TODO: Handle other OSs
struct BytecodeHeader {
#endif
    std::uint32_t id = 0xFF'00'00'2A;       ///< Moss identifier
    std::uint32_t checksum;                 ///< Checksum of the file (not used currently)
    std::uint32_t bc_version = BYTECODE_VERSION; ///< Version of bytecode used in this file
    std::uint32_t moss_version;             ///< Version od moss which compiled this
    std::uint32_t timestamp;                ///< Timestamp of the compilation

    /// \return Major version of moss encoded in the header
    uint32_t get_version_major() {
        return (moss_version & 0xFF000000) >> 24;
    }

    /// \return Minor version of moss encoded in the header
    uint32_t get_version_minor() {
        return (moss_version & 0x00FF0000) >> 16;
    }

    /// \return Patch version of moss encoded in the header
    uint32_t get_version_patch() {
        return (moss_version & 0x0000FF00) >> 8;
    }

    ustring get_version_string() {
        return std::to_string(this->get_version_major()) + "."
            + std::to_string(this->get_version_minor()) + "."
            + std::to_string(this->get_version_patch());
    }
};

inline std::ostream& operator<< (std::ostream& os, BytecodeHeader &bch) {
    time_t ts = bch.timestamp;
    os << "Bytecode header:"
       << "\n  id:                 0x" << std::hex << bch.id
       << "\n  checksum:           0x" << bch.checksum
       << "\n  bytecode version:   " << std::dec << bch.bc_version
       << "\n  moss version:       (0x" << std::hex << bch.moss_version << std::dec << ") "
          << bch.get_version_major() << "." << bch.get_version_minor() << "." << bch.get_version_patch() 
       << "\n  timestamp:          (" << bch.timestamp << ") "
       << std::dec <<  std::asctime(std::localtime(&ts));
    return os;
}

/// Creates header for bytecode with current info 
inline BytecodeHeader create_header() {
    static_assert(sizeof(BytecodeHeader) == BCH_SIZE, "Unexpected header size");

    BytecodeHeader bch;
    bch.checksum = 0;
    bch.moss_version = MOSS_VERSION_UINT32;
    bch.timestamp = std::time(nullptr);
    return bch;
}

}

}

#endif//_BYTECODE_HEADER_HPP_